<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>FirstProject2: include/LXML/ElementTime.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">FirstProject2
   &#160;<span id="projectnumber">12.12.2011</span>
   </div>
   <div id="projectbrief">Framework</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">include/LXML/ElementTime.h</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef w3c_ElementTime_h</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define w3c_ElementTime_h</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span>
<a name="l00004"></a>00004 <span class="preprocessor">#include &quot;SMILTime.h&quot;</span>
<a name="l00005"></a>00005 <span class="preprocessor">#include &quot;SMILTimeList.h&quot;</span>
<a name="l00006"></a>00006 
<a name="l00007"></a>00007 <span class="comment">//#include &quot;SVGNumberValue.h&quot;</span>
<a name="l00008"></a>00008 <span class="comment">//#include &quot;BooleanValue.h&quot;</span>
<a name="l00009"></a>00009 
<a name="l00010"></a>00010 <span class="keyword">namespace </span>System
<a name="l00011"></a>00011 {
<a name="l00012"></a>00012 <span class="keyword">namespace </span>Web
<a name="l00013"></a>00013 {
<a name="l00014"></a>00014 
<a name="l00015"></a>00015 <span class="keyword">class </span>ElementTime;
<a name="l00016"></a>00016 
<a name="l00017"></a>00017 <span class="keywordtype">double</span> ParseClockValue(StringVariant::const_iterator&lt;WCHAR&gt; s);
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 <span class="keyword">class </span>WEBEXT EnumerationAnimRestartType :
<a name="l00020"></a>00020         <span class="keyword">public</span> CSingleObject
<a name="l00021"></a>00021 {
<a name="l00022"></a>00022 <span class="keyword">public</span>:
<a name="l00023"></a>00023         RestartType m_value;
<a name="l00024"></a>00024 
<a name="l00025"></a>00025         operator RestartType ()
<a name="l00026"></a>00026         {
<a name="l00027"></a>00027                 <span class="keywordflow">return</span> m_value;
<a name="l00028"></a>00028         }
<a name="l00029"></a>00029 
<a name="l00030"></a>00030         EnumerationAnimRestartType&amp; operator = (RestartType value)
<a name="l00031"></a>00031         {
<a name="l00032"></a>00032                 m_value = value;
<a name="l00033"></a>00033                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00034"></a>00034         }
<a name="l00035"></a>00035 
<a name="l00036"></a>00036         EnumerationAnimRestartType&amp; operator += (RestartType value)
<a name="l00037"></a>00037         {
<a name="l00038"></a>00038                 m_value = value;
<a name="l00039"></a>00039                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00040"></a>00040         }
<a name="l00041"></a>00041 
<a name="l00042"></a>00042         <span class="keywordtype">void</span> setStringValue(StringIn str)
<a name="l00043"></a>00043         {
<a name="l00044"></a>00044                 <span class="keywordflow">if</span> (str == L<span class="stringliteral">&quot;always&quot;</span>)           m_value = RESTART_ALWAYS;
<a name="l00045"></a>00045                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (str == L<span class="stringliteral">&quot;never&quot;</span>)       m_value = RESTART_NEVER;
<a name="l00046"></a>00046                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (str == L<span class="stringliteral">&quot;whenNotActive&quot;</span>) m_value = RESTART_WHEN_NOT_ACTIVE;
<a name="l00047"></a>00047                 <span class="keywordflow">else</span> <span class="comment">// if (!wcscmp(str_restart, WSTR(&quot;default&quot;)))</span>
<a name="l00048"></a>00048                         m_value = RESTART_ALWAYS;
<a name="l00049"></a>00049         }
<a name="l00050"></a>00050 
<a name="l00051"></a>00051         String getStringValue()
<a name="l00052"></a>00052         {
<a name="l00053"></a>00053                 ASSERT(0);
<a name="l00054"></a>00054                 <span class="keywordflow">return</span> WSTR(<span class="stringliteral">&quot;&quot;</span>);
<a name="l00055"></a>00055         }
<a name="l00056"></a>00056 
<a name="l00057"></a>00057         <span class="keywordtype">void</span> InterpolateValue(<span class="keyword">const</span> EnumerationAnimRestartType&amp; a, <span class="keyword">const</span> EnumerationAnimRestartType&amp; b, <span class="keywordtype">double</span> t)
<a name="l00058"></a>00058         {
<a name="l00059"></a>00059                 ASSERT(0);
<a name="l00060"></a>00060         }
<a name="l00061"></a>00061 };
<a name="l00062"></a>00062 
<a name="l00063"></a>00063 <span class="keyword">class </span>WEBEXT EnumerationAnimFillType :
<a name="l00064"></a>00064         <span class="keyword">public</span> CSingleObject
<a name="l00065"></a>00065 {
<a name="l00066"></a>00066 <span class="keyword">public</span>:
<a name="l00067"></a>00067         FillType m_value;
<a name="l00068"></a>00068 
<a name="l00069"></a>00069         CTOR EnumerationAnimFillType()
<a name="l00070"></a>00070         {
<a name="l00071"></a>00071                 m_value = (FillType)-1; <span class="comment">// undefined</span>
<a name="l00072"></a>00072         }
<a name="l00073"></a>00073 
<a name="l00074"></a>00074         operator FillType ()<span class="keyword"> const</span>
<a name="l00075"></a>00075 <span class="keyword">        </span>{
<a name="l00076"></a>00076                 <span class="keywordflow">return</span> m_value;
<a name="l00077"></a>00077         }
<a name="l00078"></a>00078 
<a name="l00079"></a>00079         EnumerationAnimFillType&amp; operator = (FillType value)
<a name="l00080"></a>00080         {
<a name="l00081"></a>00081                 m_value = value;
<a name="l00082"></a>00082                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00083"></a>00083         }
<a name="l00084"></a>00084 
<a name="l00085"></a>00085         EnumerationAnimFillType&amp; operator += (FillType value)
<a name="l00086"></a>00086         {
<a name="l00087"></a>00087                 m_value = value;
<a name="l00088"></a>00088                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00089"></a>00089         }
<a name="l00090"></a>00090 
<a name="l00091"></a>00091         <span class="keywordtype">void</span> setStringValue(StringIn str)
<a name="l00092"></a>00092         {
<a name="l00093"></a>00093                 <span class="keywordflow">if</span> (str == L<span class="stringliteral">&quot;freeze&quot;</span>)
<a name="l00094"></a>00094                         m_value = FILL_FREEZE;
<a name="l00095"></a>00095                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (str == L<span class="stringliteral">&quot;remove&quot;</span>)
<a name="l00096"></a>00096                         m_value = FILL_REMOVE;
<a name="l00097"></a>00097                 <span class="keywordflow">else</span>
<a name="l00098"></a>00098                         ASSERT(0);
<a name="l00099"></a>00099         }
<a name="l00100"></a>00100 
<a name="l00101"></a>00101         <span class="keywordtype">void</span> InterpolateValue(EnumerationAnimFillType&amp; a, EnumerationAnimFillType&amp; b, <span class="keywordtype">double</span> t)
<a name="l00102"></a>00102         {
<a name="l00103"></a>00103                 ASSERT(0);
<a name="l00104"></a>00104         }
<a name="l00105"></a>00105 };
<a name="l00106"></a>00106 
<a name="l00107"></a>00107 <span class="preprocessor">#define REMAINDER(t, d) (t - d*floor(t/d))</span>
<a name="l00108"></a>00108 <span class="preprocessor"></span>
<a name="l00109"></a>00109 <span class="comment">/*</span>
<a name="l00110"></a>00110 <span class="comment">Indefinite compares &quot;greater than&quot; all resolved values, and UNRESOLVED is &quot;greater than&quot;</span>
<a name="l00111"></a>00111 <span class="comment">both resolved values and INDEFINITE</span>
<a name="l00112"></a>00112 <span class="comment">*/</span>
<a name="l00113"></a>00113 <span class="preprocessor">#define INDEFINITE      999999998</span>
<a name="l00114"></a>00114 <span class="preprocessor"></span><span class="preprocessor">#define UNRESOLVED      999999999</span>
<a name="l00115"></a>00115 <span class="preprocessor"></span>
<a name="l00116"></a>00116 <span class="keyword">class </span>WEBEXT TimeInstance : <span class="keyword">public</span> System::Object
<a name="l00117"></a>00117 <span class="comment">//      public ITimeInstance</span>
<a name="l00118"></a>00118 {
<a name="l00119"></a>00119 <span class="keyword">public</span>:
<a name="l00120"></a>00120         CTOR TimeInstance()
<a name="l00121"></a>00121         {
<a name="l00122"></a>00122                 m_time = NULL;
<a name="l00123"></a>00123                 m_syncbaseInterval = NULL;
<a name="l00124"></a>00124         }
<a name="l00125"></a>00125 
<a name="l00126"></a>00126         operator double ()<span class="keyword"> const</span>
<a name="l00127"></a>00127 <span class="keyword">        </span>{
<a name="l00128"></a>00128                 <span class="keywordflow">return</span> m_resolvedTime;<span class="comment">//m_time-&gt;m_offset;</span>
<a name="l00129"></a>00129         }
<a name="l00130"></a>00130 
<a name="l00131"></a>00131         <span class="keywordtype">bool</span> operator &gt;= (<span class="keywordtype">double</span> v)<span class="keyword"> const</span>
<a name="l00132"></a>00132 <span class="keyword">        </span>{
<a name="l00133"></a>00133                 <span class="keywordflow">return</span> (m_resolvedTime<span class="comment">/*m_time-&gt;m_offset*/</span> &gt;= v);
<a name="l00134"></a>00134         }
<a name="l00135"></a>00135 
<a name="l00136"></a>00136         <span class="keywordtype">bool</span> operator &gt; (<span class="keywordtype">double</span> v)<span class="keyword"> const</span>
<a name="l00137"></a>00137 <span class="keyword">        </span>{
<a name="l00138"></a>00138                 <span class="keywordflow">return</span> (m_resolvedTime &gt; v);
<a name="l00139"></a>00139         }
<a name="l00140"></a>00140 
<a name="l00141"></a>00141         <span class="keywordtype">bool</span> operator &lt; (<span class="keywordtype">double</span> v)<span class="keyword"> const</span>
<a name="l00142"></a>00142 <span class="keyword">        </span>{
<a name="l00143"></a>00143                 <span class="keywordflow">return</span> !(*<span class="keyword">this</span> &gt; v);
<a name="l00144"></a>00144         }
<a name="l00145"></a>00145 
<a name="l00146"></a>00146         SMILTime* get_time()
<a name="l00147"></a>00147         {
<a name="l00148"></a>00148                 <span class="keywordflow">return</span> m_time;
<a name="l00149"></a>00149         }
<a name="l00150"></a>00150 
<a name="l00151"></a>00151 <span class="keyword">public</span>:
<a name="l00152"></a>00152 
<a name="l00153"></a>00153         <span class="keywordtype">double</span> m_resolvedTime;
<a name="l00154"></a>00154 
<a name="l00155"></a>00155 <span class="comment">/*</span>
<a name="l00156"></a>00156 <span class="comment">Each instance time in one of the lists is associated with the specification</span>
<a name="l00157"></a>00157 <span class="comment">of a begin or end condition defined in the attribute syntax</span>
<a name="l00158"></a>00158 <span class="comment">*/</span>
<a name="l00159"></a>00159         SMILTime* m_time;
<a name="l00160"></a>00160 
<a name="l00161"></a>00161 <span class="comment">/*</span>
<a name="l00162"></a>00162 <span class="comment">If an instance time was defined as syncbase-values, the instance time will</span>
<a name="l00163"></a>00163 <span class="comment">maintain a time dependency relationship to the associated interval for the</span>
<a name="l00164"></a>00164 <span class="comment">syncbase element. This means that if the associated begin or end time of the</span>
<a name="l00165"></a>00165 <span class="comment">syncbase current interval changes, then the dependent instance time for this</span>
<a name="l00166"></a>00166 <span class="comment">element will change as well. </span>
<a name="l00167"></a>00167 <span class="comment">*/</span>
<a name="l00168"></a>00168 
<a name="l00169"></a>00169         TimeInterval* m_syncbaseInterval;       <span class="comment">// TODO, I&#39;m not currently using this, why not?</span>
<a name="l00170"></a>00170 
<a name="l00171"></a>00171 };
<a name="l00172"></a>00172 
<a name="l00173"></a>00173 <span class="keyword">class </span>WEBEXT InstanceTimeList
<a name="l00174"></a>00174 {
<a name="l00175"></a>00175 <span class="keyword">public</span>:
<a name="l00176"></a>00176         ~InstanceTimeList()
<a name="l00177"></a>00177         {
<a name="l00178"></a>00178                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; m_items.GetSize(); i++)
<a name="l00179"></a>00179                 {
<a name="l00180"></a>00180         <span class="comment">//              m_items[i]-&gt;Release();</span>
<a name="l00181"></a>00181                 }
<a name="l00182"></a>00182                 m_items.RemoveAll();
<a name="l00183"></a>00183         }
<a name="l00184"></a>00184 
<a name="l00185"></a>00185         <span class="keywordtype">void</span> Sort();
<a name="l00186"></a>00186 
<a name="l00187"></a>00187 <span class="keyword">public</span>:
<a name="l00188"></a>00188 
<a name="l00189"></a>00189         vector&lt;TimeInstance*&gt; m_items;
<a name="l00190"></a>00190 };
<a name="l00191"></a>00191 
<a name="l00192"></a>00192 <span class="comment">//class ElementTimeImpl;</span>
<a name="l00193"></a>00193 
<a name="l00194"></a>00194 <span class="keyword">class </span>WEBEXT TimeInterval : <span class="keyword">public</span> Object
<a name="l00195"></a>00195 {
<a name="l00196"></a>00196 <span class="keyword">public</span>:
<a name="l00197"></a>00197         CTOR TimeInterval()
<a name="l00198"></a>00198         {
<a name="l00199"></a>00199                 m_pElement = NULL;
<a name="l00200"></a>00200                 m_bActive = <span class="keyword">false</span>;
<a name="l00201"></a>00201 
<a name="l00202"></a>00202                 m_beginTime = NULL;
<a name="l00203"></a>00203         }
<a name="l00204"></a>00204 
<a name="l00205"></a>00205         <span class="keywordtype">void</span> Set(TimeInstance* beginTime, <span class="keywordtype">double</span> begin, <span class="keywordtype">double</span> end)
<a name="l00206"></a>00206         {
<a name="l00207"></a>00207                 m_beginTime = beginTime;
<a name="l00208"></a>00208                 m_begin = begin;
<a name="l00209"></a>00209                 m_end = end;
<a name="l00210"></a>00210         }
<a name="l00211"></a>00211 
<a name="l00212"></a>00212         TimeInstance* get_beginInstanceTime()<span class="keyword"> const</span>
<a name="l00213"></a>00213 <span class="keyword">        </span>{
<a name="l00214"></a>00214                 <span class="keywordflow">return</span> m_beginTime;
<a name="l00215"></a>00215         }
<a name="l00216"></a>00216 
<a name="l00217"></a>00217         <span class="keywordtype">double</span> get_beginInstanceTime()
<a name="l00218"></a>00218         {
<a name="l00219"></a>00219                 ASSERT(0);
<a name="l00220"></a>00220                 <span class="keywordflow">return</span> 0;
<a name="l00221"></a>00221         }
<a name="l00222"></a>00222 
<a name="l00223"></a>00223         <span class="keywordtype">double</span> get_resolvedBegin()
<a name="l00224"></a>00224         {
<a name="l00225"></a>00225                 <span class="keywordflow">return</span> m_begin;
<a name="l00226"></a>00226         }
<a name="l00227"></a>00227 
<a name="l00228"></a>00228         <span class="keywordtype">double</span> get_resolvedEnd()
<a name="l00229"></a>00229         {
<a name="l00230"></a>00230                 <span class="keywordflow">return</span> m_end;
<a name="l00231"></a>00231         }
<a name="l00232"></a>00232 
<a name="l00233"></a>00233         TimeInterval* getNextInterval()
<a name="l00234"></a>00234         {
<a name="l00235"></a>00235                 <span class="keywordflow">return</span> NULL;
<a name="l00236"></a>00236         }
<a name="l00237"></a>00237 
<a name="l00238"></a>00238 <span class="keyword">public</span>:
<a name="l00239"></a>00239 
<a name="l00240"></a>00240         <span class="keywordtype">double</span> m_begin;
<a name="l00241"></a>00241         <span class="keywordtype">double</span> m_end;
<a name="l00242"></a>00242         TimeInstance* m_beginTime;      <span class="comment">// ??</span>
<a name="l00243"></a>00243 <span class="comment">//      CInstanceTime* m_endTime;       // ??</span>
<a name="l00244"></a>00244         ElementTime* m_pElement;
<a name="l00245"></a>00245 
<a name="l00246"></a>00246         <span class="keywordtype">bool</span> m_bActive;
<a name="l00247"></a>00247 };
<a name="l00248"></a>00248 
<a name="l00249"></a>00249 <span class="preprocessor">#if 0</span>
<a name="l00250"></a>00250 <span class="preprocessor"></span><span class="keyword">class </span>WEBEXT ElementTimeImpl : <span class="keyword">public</span> System::Object
<a name="l00251"></a>00251 {
<a name="l00252"></a>00252 <span class="keyword">public</span>:
<a name="l00253"></a>00253         CTOR ElementTimeImpl(Element* ownerElement) : m_ownerElement(ownerElement)
<a name="l00254"></a>00254         {
<a name="l00255"></a>00255                 m_iteration = 0;
<a name="l00256"></a>00256         }
<a name="l00257"></a>00257 
<a name="l00258"></a>00258         <span class="keyword">virtual</span> ~ElementTimeImpl()
<a name="l00259"></a>00259         {
<a name="l00260"></a>00260         }
<a name="l00261"></a>00261 
<a name="l00262"></a>00262         <span class="keyword">virtual</span> <span class="keywordtype">void</span> NotifySync(Element* syncbaseElement, TimeInterval* pInterval<span class="comment">/*, bool baseBegin*/</span>) = 0;
<a name="l00263"></a>00263         <span class="keyword">virtual</span> TimeInterval* GetFirstInterval() = 0;
<a name="l00264"></a>00264 
<a name="l00265"></a>00265         <span class="keyword">virtual</span> <span class="keywordtype">void</span> Init() = 0;
<a name="l00266"></a>00266         <span class="keyword">virtual</span> <span class="keywordtype">void</span> Init2() = 0;
<a name="l00267"></a>00267         <span class="keyword">virtual</span> <span class="keywordtype">void</span> Reset() = 0;
<a name="l00268"></a>00268         <span class="keyword">virtual</span> <span class="keywordtype">void</span> Run() = 0;
<a name="l00269"></a>00269         <span class="keyword">virtual</span> <span class="keywordtype">void</span> CalculateSimpleDuration() = 0;
<a name="l00270"></a>00270         <span class="keyword">virtual</span> IElementTimeContainer* get_parentTimeContainer() = 0;
<a name="l00271"></a>00271 
<a name="l00272"></a>00272 <span class="comment">//      virtual void RecalculateTime() = 0;     // Called when one of the children have changed</span>
<a name="l00273"></a>00273         <span class="keyword">virtual</span> <span class="keywordtype">void</span> CalculateTimeBeforeParent() = 0;   <span class="comment">// Called by parent</span>
<a name="l00274"></a>00274         <span class="keyword">virtual</span> <span class="keywordtype">void</span> CalculateTimeAfterParent() = 0;    <span class="comment">// Called by parent</span>
<a name="l00275"></a>00275 
<a name="l00276"></a>00276         <span class="keyword">virtual</span> <span class="keywordtype">void</span> Seek(<span class="keywordtype">double</span> tps);
<a name="l00277"></a>00277 
<a name="l00278"></a>00278         <span class="keywordtype">double</span> ActiveTimeToSimpleTime(<span class="keywordtype">double</span> tau);
<a name="l00279"></a>00279         <span class="keywordtype">double</span> SimpleTimeToActiveTime(<span class="keywordtype">double</span> tsf);
<a name="l00280"></a>00280 
<a name="l00281"></a>00281 <span class="comment">// Seek is only implemented here and calls Activate/Deactivate handled by</span>
<a name="l00282"></a>00282 <span class="comment">// the classes derived from IElementTime</span>
<a name="l00283"></a>00283 
<a name="l00284"></a>00284         <span class="keyword">virtual</span> <span class="keywordtype">void</span> ActiveToInactive()
<a name="l00285"></a>00285         {
<a name="l00286"></a>00286         }
<a name="l00287"></a>00287 
<a name="l00288"></a>00288         <span class="keyword">virtual</span> <span class="keywordtype">void</span> InactiveToActive()
<a name="l00289"></a>00289         {
<a name="l00290"></a>00290         }
<a name="l00291"></a>00291 
<a name="l00292"></a>00292         <span class="keyword">virtual</span> <span class="keywordtype">void</span> EndCurrentIntervalAt(<span class="keywordtype">double</span> endt) = 0;
<a name="l00293"></a>00293 
<a name="l00294"></a>00294         TimeInstance* GetNextInstanceTime(<span class="keywordtype">double</span> beginAfter)
<a name="l00295"></a>00295         {
<a name="l00296"></a>00296                 <span class="comment">//double beginAfter = m_pCurrentInterval-&gt;m_begin;</span>
<a name="l00297"></a>00297 
<a name="l00298"></a>00298                 <span class="comment">//double tempBegin;</span>
<a name="l00299"></a>00299 
<a name="l00300"></a>00300                 <span class="keywordtype">int</span> i;
<a name="l00301"></a>00301                 <span class="keywordflow">for</span> (i = 0; i &lt; m_instanceBeginList.m_items.GetSize(); i++)
<a name="l00302"></a>00302                 {
<a name="l00303"></a>00303                         <span class="keywordflow">if</span> (*m_instanceBeginList.m_items[i] &gt; beginAfter)
<a name="l00304"></a>00304                         {
<a name="l00305"></a>00305                         <span class="comment">//      tempBegin = *m_instanceBeginList.m_items[i];</span>
<a name="l00306"></a>00306                                 <span class="keywordflow">break</span>;
<a name="l00307"></a>00307                         }
<a name="l00308"></a>00308                 }
<a name="l00309"></a>00309 
<a name="l00310"></a>00310                 <span class="keywordflow">if</span> (i &lt; m_instanceBeginList.m_items.GetSize())
<a name="l00311"></a>00311                 {
<a name="l00312"></a>00312 <span class="comment">//                      if (*m_instanceBeginList.m_items[i] &lt; m_pCurrentInterval-&gt;m_end)</span>
<a name="l00313"></a>00313                         {
<a name="l00314"></a>00314                                 <span class="keywordflow">return</span> m_instanceBeginList.m_items[i];
<a name="l00315"></a>00315                         }
<a name="l00316"></a>00316                 }
<a name="l00317"></a>00317 
<a name="l00318"></a>00318                 <span class="keywordflow">return</span> NULL;
<a name="l00319"></a>00319         }
<a name="l00320"></a>00320 
<a name="l00321"></a>00321 <span class="keyword">public</span>:
<a name="l00322"></a>00322 
<a name="l00323"></a>00323         <span class="keywordtype">double</span> m_parentSimpleTime;
<a name="l00324"></a>00324 
<a name="l00325"></a>00325         Element* m_ownerElement;
<a name="l00326"></a>00326 
<a name="l00327"></a>00327         <span class="keywordtype">int</span> m_iteration;
<a name="l00328"></a>00328 
<a name="l00329"></a>00329         <span class="keywordtype">double</span> m_tau;   <span class="comment">// Unfiltered active time</span>
<a name="l00330"></a>00330         <span class="keywordtype">double</span> m_tsf;   <span class="comment">// Filtered simple time</span>
<a name="l00331"></a>00331 
<a name="l00332"></a>00332         <span class="keywordtype">double</span> m_dur;   <span class="comment">// &#39;dur&#39; attribute, desired simple time (&lt;0 means indefinite)</span>
<a name="l00333"></a>00333         <span class="keywordtype">double</span> m_AD;    <span class="comment">// Active Duration</span>
<a name="l00334"></a>00334         <span class="keywordtype">double</span> m_simpleDur;     <span class="comment">// Simple duration (autoReverse Accounted for)</span>
<a name="l00335"></a>00335 
<a name="l00336"></a>00336         <span class="keywordtype">double</span> m_clipBegin;     <span class="comment">// TODO, improve</span>
<a name="l00337"></a>00337 
<a name="l00338"></a>00338 <span class="comment">//      CComObject&lt;CXMLAttr2T&lt;CComObjectCreateInstance&lt;CValueTypeWrapper&lt;CLClockValue&gt; &gt; &gt; &gt;* m_dur;</span>
<a name="l00339"></a>00339 
<a name="l00340"></a>00340         InstanceTimeList m_instanceBeginList;
<a name="l00341"></a>00341         InstanceTimeList m_instanceEndList;
<a name="l00342"></a>00342         vector&lt;TimeInterval*&gt; m_intervals;
<a name="l00343"></a>00343         TimeInterval* m_pCurrentInterval;
<a name="l00344"></a>00344 
<a name="l00345"></a>00345         vector&lt;ElementTimeImpl*&gt; m_syncDependants;
<a name="l00346"></a>00346 
<a name="l00347"></a>00347 <span class="comment">//      CComObject&lt;CXMLAttr2T&lt;CComObjectCreateInstance&lt;CValueTypeWrapper&lt;CDurationValue&gt; &gt; &gt; &gt;* m_dur;</span>
<a name="l00348"></a>00348 
<a name="l00349"></a>00349         SMILTimeList* m_begin;
<a name="l00350"></a>00350         SMILTimeList* m_end;
<a name="l00351"></a>00351         <span class="keywordtype">double</span> m_repeatCount;
<a name="l00352"></a>00352         <span class="keywordtype">double</span> m_repeatDur;
<a name="l00353"></a>00353         AnimRestartType m_restart;
<a name="l00354"></a>00354         AnimFillType m_fill;
<a name="l00355"></a>00355         <span class="keywordtype">double</span> m_accelerate;
<a name="l00356"></a>00356         <span class="keywordtype">double</span> m_decelerate;
<a name="l00357"></a>00357         <span class="keywordtype">double</span> m_speed;
<a name="l00358"></a>00358         <span class="keywordtype">bool</span> m_autoReverse;
<a name="l00359"></a>00359 
<a name="l00360"></a>00360         Attr* m_durAttr;
<a name="l00361"></a>00361         Attr* m_beginAttr;
<a name="l00362"></a>00362         Attr* m_endAttr;
<a name="l00363"></a>00363         Attr* m_repeatDurAttr;
<a name="l00364"></a>00364         Attr* m_restartAttr;
<a name="l00365"></a>00365         Attr* m_fillAttr;
<a name="l00366"></a>00366         Attr* m_accelerateAttr;
<a name="l00367"></a>00367         Attr* m_decelerateAttr;
<a name="l00368"></a>00368         Attr* m_speedAttr;
<a name="l00369"></a>00369         Attr* m_autoReverseAttr;
<a name="l00370"></a>00370 };
<a name="l00371"></a>00371 <span class="preprocessor">#endif</span>
<a name="l00372"></a>00372 <span class="preprocessor"></span>
<a name="l00373"></a>00373 <span class="keyword">class </span>WEBEXT ElementTime : <span class="keyword">public</span> Object<span class="comment">//ElementTimeImpl</span>
<a name="l00374"></a>00374 {
<a name="l00375"></a>00375 <span class="keyword">public</span>:
<a name="l00376"></a>00376         CTOR ElementTime(Element* ownerElement);
<a name="l00377"></a>00377         ~ElementTime();
<a name="l00378"></a>00378 
<a name="l00379"></a>00379 <span class="preprocessor">#if 0</span>
<a name="l00380"></a>00380 <span class="preprocessor"></span>        <span class="keywordtype">int</span> FinalConstruct()
<a name="l00381"></a>00381         {
<a name="l00382"></a>00382                 <span class="keyword">static_cast&lt;</span>T*<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;AddXMLAttribute(NewNXMLAttr(&amp;m_restart, WSTR(<span class="stringliteral">&quot;&quot;</span>), WSTR(<span class="stringliteral">&quot;restart&quot;</span>), WSTR(<span class="stringliteral">&quot;always&quot;</span>)));
<a name="l00383"></a>00383                 <span class="keyword">static_cast&lt;</span>T*<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;AddXMLAttribute(NewNXMLAttr(&amp;m_repeatCount, WSTR(<span class="stringliteral">&quot;&quot;</span>), WSTR(<span class="stringliteral">&quot;repeatCount&quot;</span>), WSTR(<span class="stringliteral">&quot;1&quot;</span>)));
<a name="l00384"></a>00384                 <span class="keyword">static_cast&lt;</span>T*<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;AddXMLAttribute(NewNXMLAttr(&amp;m_repeatDur, WSTR(<span class="stringliteral">&quot;&quot;</span>), WSTR(<span class="stringliteral">&quot;repeatDur&quot;</span>), WSTR(<span class="stringliteral">&quot;0&quot;</span>)));
<a name="l00385"></a>00385                 <span class="keyword">static_cast&lt;</span>T*<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;AddXMLAttribute(NewNXMLAttr(&amp;m_fill, WSTR(<span class="stringliteral">&quot;&quot;</span>), WSTR(<span class="stringliteral">&quot;fill&quot;</span>), WSTR(<span class="stringliteral">&quot;remove&quot;</span>)));
<a name="l00386"></a>00386                 <span class="keyword">static_cast&lt;</span>T*<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;AddXMLAttribute(NewNXMLAttr(&amp;m_accelerate, WSTR(<span class="stringliteral">&quot;&quot;</span>), WSTR(<span class="stringliteral">&quot;accelerate&quot;</span>), WSTR(<span class="stringliteral">&quot;0&quot;</span>)));
<a name="l00387"></a>00387                 <span class="keyword">static_cast&lt;</span>T*<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;AddXMLAttribute(NewNXMLAttr(&amp;m_decelerate, WSTR(<span class="stringliteral">&quot;&quot;</span>), WSTR(<span class="stringliteral">&quot;decelerate&quot;</span>), WSTR(<span class="stringliteral">&quot;0&quot;</span>)));
<a name="l00388"></a>00388                 <span class="keyword">static_cast&lt;</span>T*<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;AddXMLAttribute(NewNXMLAttr(&amp;m_speed, WSTR(<span class="stringliteral">&quot;&quot;</span>), WSTR(<span class="stringliteral">&quot;speed&quot;</span>), WSTR(<span class="stringliteral">&quot;1&quot;</span>)));
<a name="l00389"></a>00389                 <span class="keyword">static_cast&lt;</span>T*<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;AddXMLAttribute(NewNXMLAttr(&amp;m_autoReverse, WSTR(<span class="stringliteral">&quot;&quot;</span>), WSTR(<span class="stringliteral">&quot;autoReverse&quot;</span>), WSTR(<span class="stringliteral">&quot;false&quot;</span>)));
<a name="l00390"></a>00390 
<a name="l00391"></a>00391                 NewNXMLAttr(&amp;m_begin, WSTR(<span class="stringliteral">&quot;&quot;</span>), WSTR(<span class="stringliteral">&quot;begin&quot;</span>), WSTR(<span class="stringliteral">&quot;0s&quot;</span>));
<a name="l00392"></a>00392                 m_begin-&gt;m_value-&gt;m_value-&gt;m_ownerElement = <span class="keyword">static_cast&lt;</span>T*<span class="keyword">&gt;</span>(<span class="keyword">this</span>);
<a name="l00393"></a>00393                 <span class="keyword">static_cast&lt;</span>T*<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;AddXMLAttribute(m_begin);
<a name="l00394"></a>00394         <span class="comment">//      m_begin-&gt;m_pListener = this;</span>
<a name="l00395"></a>00395 
<a name="l00396"></a>00396                 NewNXMLAttr(&amp;m_end, WSTR(<span class="stringliteral">&quot;&quot;</span>), WSTR(<span class="stringliteral">&quot;end&quot;</span>), NULL);
<a name="l00397"></a>00397                 m_end-&gt;m_value-&gt;m_value-&gt;m_ownerElement = <span class="keyword">static_cast&lt;</span>T*<span class="keyword">&gt;</span>(<span class="keyword">this</span>);
<a name="l00398"></a>00398                 <span class="keyword">static_cast&lt;</span>T*<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;AddXMLAttribute(m_end);
<a name="l00399"></a>00399         <span class="comment">//      m_end-&gt;m_pListener = this;</span>
<a name="l00400"></a>00400 
<a name="l00401"></a>00401                 <span class="keywordflow">return</span> S_OK;
<a name="l00402"></a>00402         }
<a name="l00403"></a>00403 
<a name="l00404"></a>00404         <span class="keywordtype">void</span> FinalRelease()
<a name="l00405"></a>00405         {
<a name="l00406"></a>00406                 <span class="keywordflow">if</span> (m_pCurrentInterval)
<a name="l00407"></a>00407                 {
<a name="l00408"></a>00408                         m_pCurrentInterval-&gt;Release();
<a name="l00409"></a>00409                         m_pCurrentInterval = NULL;
<a name="l00410"></a>00410                 }
<a name="l00411"></a>00411         }
<a name="l00412"></a>00412 <span class="preprocessor">#endif</span>
<a name="l00413"></a>00413 <span class="preprocessor"></span>
<a name="l00414"></a>00414         <span class="comment">/*</span>
<a name="l00415"></a>00415 <span class="comment">        virtual void OnChanged(CSingleObject* pObject)</span>
<a name="l00416"></a>00416 <span class="comment">        {</span>
<a name="l00417"></a>00417 <span class="comment">                if (pObject == m_begin-&gt;m_value-&gt;m_value)</span>
<a name="l00418"></a>00418 <span class="comment">                {</span>
<a name="l00419"></a>00419 <span class="comment">                        m_begin-&gt;OnBaseValChanged();</span>
<a name="l00420"></a>00420 <span class="comment">                }</span>
<a name="l00421"></a>00421 <span class="comment">                else if (pObject == m_end-&gt;m_value-&gt;m_value)</span>
<a name="l00422"></a>00422 <span class="comment">                {</span>
<a name="l00423"></a>00423 <span class="comment">                        m_end-&gt;OnBaseValChanged();</span>
<a name="l00424"></a>00424 <span class="comment">                }</span>
<a name="l00425"></a>00425 <span class="comment">        }</span>
<a name="l00426"></a>00426 <span class="comment">        */</span>
<a name="l00427"></a>00427 
<a name="l00428"></a>00428         <span class="keyword">virtual</span> <span class="keywordtype">double</span> GetIntrinsicDuration()
<a name="l00429"></a>00429         {
<a name="l00430"></a>00430                 <span class="keywordflow">return</span> 0;
<a name="l00431"></a>00431         }
<a name="l00432"></a>00432 
<a name="l00433"></a>00433         <span class="keyword">virtual</span> <span class="keywordtype">double</span> GetImplicitDuration()
<a name="l00434"></a>00434         {
<a name="l00435"></a>00435                 ASSERT(0);
<a name="l00436"></a>00436                 <span class="keywordflow">return</span> 0;
<a name="l00437"></a>00437 <span class="preprocessor">#if 0</span>
<a name="l00438"></a>00438 <span class="preprocessor"></span>                <span class="keywordtype">double</span> intrinsic = GetIntrinsicDuration();
<a name="l00439"></a>00439 
<a name="l00440"></a>00440                 <span class="keywordtype">double</span> clipEnd = intrinsic-m_clipBegin;
<a name="l00441"></a>00441                 {
<a name="l00442"></a>00442                         CComBSTR str;
<a name="l00443"></a>00443                         <span class="keyword">static_cast&lt;</span>T*<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;getAttribute(WSTR(<span class="stringliteral">&quot;clipEnd&quot;</span>), &amp;str);
<a name="l00444"></a>00444                         <span class="keywordflow">if</span> ((BSTR)str != NULL)
<a name="l00445"></a>00445                         {
<a name="l00446"></a>00446                                 clipEnd = atof(_bstr_t(str));
<a name="l00447"></a>00447                         }
<a name="l00448"></a>00448                 }
<a name="l00449"></a>00449 
<a name="l00450"></a>00450                 <span class="keywordflow">return</span> clipEnd-m_clipBegin;
<a name="l00451"></a>00451 <span class="preprocessor">#endif</span>
<a name="l00452"></a>00452 <span class="preprocessor"></span>        }
<a name="l00453"></a>00453 
<a name="l00454"></a>00454         <span class="comment">// Define simple duration</span>
<a name="l00455"></a>00455         <span class="keyword">virtual</span> <span class="keywordtype">void</span> CalculateSimpleDuration();
<a name="l00456"></a>00456 
<a name="l00457"></a>00457         <span class="keyword">virtual</span> IElementTimeContainer* get_parentTimeContainer();
<a name="l00458"></a>00458 
<a name="l00459"></a>00459 <span class="comment">// Called before children have been initialized</span>
<a name="l00460"></a>00460         <span class="keyword">virtual</span> <span class="keywordtype">void</span> Init();
<a name="l00461"></a>00461 
<a name="l00462"></a>00462 <span class="comment">// Called after children have been initialized</span>
<a name="l00463"></a>00463         <span class="keyword">virtual</span> <span class="keywordtype">void</span> Init2();
<a name="l00464"></a>00464 
<a name="l00465"></a>00465         <span class="keyword">virtual</span> <span class="keywordtype">void</span> EndCurrentIntervalAt(<span class="keywordtype">double</span> endt);
<a name="l00466"></a>00466 
<a name="l00467"></a>00467 
<a name="l00468"></a>00468 <span class="comment">//      CArray&lt;IElementTime*,IElementTime*&gt; m_syncDependants;</span>
<a name="l00469"></a>00469 <span class="comment">//      CArray&lt;CLElementTimeImpl*,CLElementTimeImpl*&gt; m_syncDependants;</span>
<a name="l00470"></a>00470 
<a name="l00471"></a>00471 <span class="comment">/*</span>
<a name="l00472"></a>00472 <span class="comment">SMIL:</span>
<a name="l00473"></a>00473 <span class="comment"></span>
<a name="l00474"></a>00474 <span class="comment">When a time container repeats or restarts, all descendent children are &quot;reset&quot; with</span>
<a name="l00475"></a>00475 <span class="comment">respect to certain state: </span>
<a name="l00476"></a>00476 <span class="comment"></span>
<a name="l00477"></a>00477 <span class="comment">Any instance times associated with past event-values, repeat-values,</span>
<a name="l00478"></a>00478 <span class="comment">accesskey-values or added via DOM method calls are removed from the dependent</span>
<a name="l00479"></a>00479 <span class="comment">begin and end instance times lists. In effect, all events and DOM methods</span>
<a name="l00480"></a>00480 <span class="comment">calls in the past are cleared. This does not apply to an instance time that</span>
<a name="l00481"></a>00481 <span class="comment">defines the begin of the current interval. </span>
<a name="l00482"></a>00482 <span class="comment"></span>
<a name="l00483"></a>00483 <span class="comment">Any syncbase times are reevaluated (i.e. the translation between timespaces</span>
<a name="l00484"></a>00484 <span class="comment">must be recalculated - see Converting between local and global times). </span>
<a name="l00485"></a>00485 <span class="comment">A resolved syncbase time is removed from the dependent instance time list</span>
<a name="l00486"></a>00486 <span class="comment">when a common ascendant of the syncbase and the dependent element restarts</span>
<a name="l00487"></a>00487 <span class="comment">or repeats </span>
<a name="l00488"></a>00488 <span class="comment"></span>
<a name="l00489"></a>00489 <span class="comment">Any state associated with the interpretation of the restart semantics is</span>
<a name="l00490"></a>00490 <span class="comment">reset. </span>
<a name="l00491"></a>00491 <span class="comment">*/</span>
<a name="l00492"></a>00492         <span class="keyword">virtual</span> <span class="keywordtype">void</span> Reset()
<a name="l00493"></a>00493         {
<a name="l00494"></a>00494                 ASSERT(0);
<a name="l00495"></a>00495 <span class="preprocessor">#if 0</span>
<a name="l00496"></a>00496 <span class="preprocessor"></span>                m_tau = -1;
<a name="l00497"></a>00497                 m_parentSimpleTime = -1;
<a name="l00498"></a>00498 
<a name="l00499"></a>00499                 <span class="keywordflow">if</span> (m_pCurrentInterval)
<a name="l00500"></a>00500                 {
<a name="l00501"></a>00501                         m_pCurrentInterval-&gt;Release();
<a name="l00502"></a>00502                         m_pCurrentInterval = NULL;
<a name="l00503"></a>00503                 }
<a name="l00504"></a>00504 
<a name="l00505"></a>00505                 {
<a name="l00506"></a>00506                         CComPtr&lt;ILDOMNode&gt; node;
<a name="l00507"></a>00507                         ((ILDOMNode*)static_cast&lt;T*&gt;(<span class="keyword">this</span>))-&gt;get_firstChild(&amp;node);
<a name="l00508"></a>00508                         <span class="keywordflow">while</span> (node)
<a name="l00509"></a>00509                         {
<a name="l00510"></a>00510                                 CComQIPtr&lt;CLElementTimeImpl, &amp;IID_IUnknown<span class="comment">/*TODO*/</span>&gt; elementTime((IUnknown*)node);
<a name="l00511"></a>00511                                 <span class="keywordflow">if</span> (elementTime)
<a name="l00512"></a>00512                                 {
<a name="l00513"></a>00513                                         elementTime-&gt;Reset();
<a name="l00514"></a>00514                                 }
<a name="l00515"></a>00515 
<a name="l00516"></a>00516                                 CComPtr&lt;ILDOMNode&gt; nextSibling;
<a name="l00517"></a>00517                                 node-&gt;get_nextSibling(&amp;nextSibling);
<a name="l00518"></a>00518                                 node = nextSibling;
<a name="l00519"></a>00519                         }
<a name="l00520"></a>00520                 }
<a name="l00521"></a>00521 
<a name="l00522"></a>00522                 Init2();        <span class="comment">// Create first interval ?</span>
<a name="l00523"></a>00523                 <span class="comment">//m_pCurrentInterval = GetFirstInterval();      // ????</span>
<a name="l00524"></a>00524 
<a name="l00525"></a>00525                 {
<a name="l00526"></a>00526                         CComPtr&lt;ILDOMNode&gt; node;
<a name="l00527"></a>00527                         ((ILDOMNode*)static_cast&lt;T*&gt;(<span class="keyword">this</span>))-&gt;get_firstChild(&amp;node);
<a name="l00528"></a>00528                         <span class="keywordflow">while</span> (node)
<a name="l00529"></a>00529                         {
<a name="l00530"></a>00530                                 CComQIPtr&lt;CLElementTimeImpl, &amp;IID_IUnknown<span class="comment">/*TODO*/</span>&gt; elementTime((IUnknown*)node);
<a name="l00531"></a>00531                                 <span class="keywordflow">if</span> (elementTime)
<a name="l00532"></a>00532                                 {
<a name="l00533"></a>00533                                         elementTime-&gt;Init2();
<a name="l00534"></a>00534                                 }
<a name="l00535"></a>00535 
<a name="l00536"></a>00536                                 CComPtr&lt;ILDOMNode&gt; nextSibling;
<a name="l00537"></a>00537                                 node-&gt;get_nextSibling(&amp;nextSibling);
<a name="l00538"></a>00538                                 node = nextSibling;
<a name="l00539"></a>00539                         }
<a name="l00540"></a>00540                 }
<a name="l00541"></a>00541 <span class="preprocessor">#endif</span>
<a name="l00542"></a>00542 <span class="preprocessor"></span>        }
<a name="l00543"></a>00543 
<a name="l00544"></a>00544 <span class="comment">/*</span>
<a name="l00545"></a>00545 <span class="comment">SMIL: * 10.3.3 Semantics of the Timing Model *</span>
<a name="l00546"></a>00546 <span class="comment"></span>
<a name="l00547"></a>00547 <span class="comment">        When a dependent element gets a &quot;new interval&quot; notice, this includes a reference</span>
<a name="l00548"></a>00548 <span class="comment">        to the new interval. The new interval will generally have a resolved begin time</span>
<a name="l00549"></a>00549 <span class="comment">        and may have a resolved end time. An associated instance time will be added to the</span>
<a name="l00550"></a>00550 <span class="comment">        begin or end instance time list for the dependent element, and this new instance</span>
<a name="l00551"></a>00551 <span class="comment">        time will maintain a time dependency relationship to the syncbase interval. </span>
<a name="l00552"></a>00552 <span class="comment"></span>
<a name="l00553"></a>00553 <span class="comment">  Also:</span>
<a name="l00554"></a>00554 <span class="comment">        If the element receives a &quot;new interval&quot; notice while it is active, it will add</span>
<a name="l00555"></a>00555 <span class="comment">        the associated time (i.e. the begin or end time of the syncbase interval) to the</span>
<a name="l00556"></a>00556 <span class="comment">        appropriate list of resolved times. If the new interval adds a time to the begin</span>
<a name="l00557"></a>00557 <span class="comment">        list, restart semantics are considered, and this may end the current interval</span>
<a name="l00558"></a>00558 <span class="comment"></span>
<a name="l00559"></a>00559 <span class="comment">*/</span>
<a name="l00560"></a>00560 
<a name="l00561"></a>00561         <span class="comment">// virtual</span>
<a name="l00562"></a>00562         <span class="keywordtype">void</span> NotifySync(Element* syncbaseElement, TimeInterval* pInterval<span class="comment">/*, bool baseBegin*/</span>)
<a name="l00563"></a>00563         {
<a name="l00564"></a>00564                 ASSERT(0);
<a name="l00565"></a>00565 <span class="preprocessor">#if 0</span>
<a name="l00566"></a>00566 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00567"></a>00567 <span class="comment">        Each time the syncbase element creates a new interval, the condition yields</span>
<a name="l00568"></a>00568 <span class="comment">        a single instance time. The time plus or minus any offset is added to the</span>
<a name="l00569"></a>00569 <span class="comment">        list</span>
<a name="l00570"></a>00570 <span class="comment">*/</span>
<a name="l00571"></a>00571                 <span class="keywordtype">int</span> i;
<a name="l00572"></a>00572 
<a name="l00573"></a>00573                 <span class="keywordflow">for</span> (i = 0; i &lt; m_begin-&gt;m_value-&gt;m_value-&gt;m_items.GetSize(); i++)
<a name="l00574"></a>00574                 {
<a name="l00575"></a>00575                         CComObject&lt;SMILTime&gt;* pTime = m_begin-&gt;m_value-&gt;m_value-&gt;m_items[i];
<a name="l00576"></a>00576 
<a name="l00577"></a>00577                         CComPtr&lt;ILDOMElement&gt; baseElement;
<a name="l00578"></a>00578                         pTime-&gt;get_baseElement(&amp;baseElement);
<a name="l00579"></a>00579 
<a name="l00580"></a>00580                         <span class="keywordflow">if</span> (baseElement == syncbaseElement)
<a name="l00581"></a>00581                         {
<a name="l00582"></a>00582                                 TimeInstance* pInstanceTime = <span class="keyword">new</span> TimeInstance;
<a name="l00583"></a>00583 
<a name="l00584"></a>00584                                 pInstanceTime-&gt;m_time = pTime;
<a name="l00585"></a>00585 
<a name="l00586"></a>00586                         <span class="comment">// TODO, check that the appropriate time is resolved?</span>
<a name="l00587"></a>00587                                 pTime-&gt;m_resolved = VARIANT_TRUE;
<a name="l00588"></a>00588                                 <span class="keywordflow">if</span> (pTime-&gt;m_baseBegin) <span class="comment">// ??</span>
<a name="l00589"></a>00589                                         pTime-&gt;m_resolvedOffset = pInterval-&gt;m_begin + pTime-&gt;m_offset;
<a name="l00590"></a>00590                                 <span class="keywordflow">else</span>
<a name="l00591"></a>00591                                         pTime-&gt;m_resolvedOffset = pInterval-&gt;m_end + pTime-&gt;m_offset;
<a name="l00592"></a>00592 
<a name="l00593"></a>00593                                 pInstanceTime-&gt;m_resolvedTime = pTime-&gt;m_resolvedOffset;<span class="comment">//pInterval-&gt;m_end + pTime-&gt;m_offset;</span>
<a name="l00594"></a>00594 
<a name="l00595"></a>00595                                 <span class="comment">//if (pTime-&gt;m_baseBegin)</span>
<a name="l00596"></a>00596                                 {
<a name="l00597"></a>00597                                         <span class="keyword">static_cast&lt;</span>T*<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;m_instanceBeginList.m_items.Add(pInstanceTime);
<a name="l00598"></a>00598 
<a name="l00599"></a>00599 <span class="comment">/*</span>
<a name="l00600"></a>00600 <span class="comment">1</span>
<a name="l00601"></a>00601 <span class="comment">When the current interval is playing, if restart=&quot;always&quot; then any instance time</span>
<a name="l00602"></a>00602 <span class="comment">(call it T) in the begin list that is after (i.e. later than) the current</span>
<a name="l00603"></a>00603 <span class="comment">interval begin but earlier than the current interval end will cause the current</span>
<a name="l00604"></a>00604 <span class="comment">interval to end at time T. This is the first step in restarting the element:</span>
<a name="l00605"></a>00605 <span class="comment">when the current interval ends, that in turn will create any following interval. </span>
<a name="l00606"></a>00606 <span class="comment"></span>
<a name="l00607"></a>00607 <span class="comment">2.</span>
<a name="l00608"></a>00608 <span class="comment">....</span>
<a name="l00609"></a>00609 <span class="comment">        -If the current interval is waiting to play, the element recalculates the begin and</span>
<a name="l00610"></a>00610 <span class="comment">        end times for the current interval, as described in the Element life-cycle step 1</span>
<a name="l00611"></a>00611 <span class="comment">        (for the first interval) or step 4 (for all later intervals). If either the begin</span>
<a name="l00612"></a>00612 <span class="comment">        or end time of the current interval changes, these changes must be propagated to</span>
<a name="l00613"></a>00613 <span class="comment">        time dependents accordingly. </span>
<a name="l00614"></a>00614 <span class="comment"></span>
<a name="l00615"></a>00615 <span class="comment">        -If the current interval is playing (i.e. it is active), then the restart setting determines the behavior: </span>
<a name="l00616"></a>00616 <span class="comment">                If restart=&quot;never&quot; then nothing more is done. It is possible (if the new instance time is associated with a syncbase value condition) that the new instance time will be used the next time the element life cycle begins. </span>
<a name="l00617"></a>00617 <span class="comment">                If restart=&quot;whenNotActive&quot; then nothing more is done. If the time falls within the current interval, the element cannot restart, and if it falls after, then the normal processing at the end of the current interval will handle it. If the time falls before the current interval, as can happen if the time includes a negative offset, the element does not restart (the new instance time is effectively ignored). </span>
<a name="l00618"></a>00618 <span class="comment">                If restart=&quot;always&quot; then case 1 above applies, and will cause the current interval to end. </span>
<a name="l00619"></a>00619 <span class="comment"></span>
<a name="l00620"></a>00620 <span class="comment">*/</span>
<a name="l00621"></a>00621                                         <span class="keywordflow">if</span> (m_pCurrentInterval)
<a name="l00622"></a>00622                                         {
<a name="l00623"></a>00623                                                 <span class="keywordflow">if</span> (!m_pCurrentInterval-&gt;m_bActive)     <span class="comment">// Waiting to play</span>
<a name="l00624"></a>00624                                                 {
<a name="l00625"></a>00625                                                         <span class="comment">// TODO ASSERT(0);</span>
<a name="l00626"></a>00626                                                 }
<a name="l00627"></a>00627                                                 <span class="keywordflow">else</span>    <span class="comment">// Current interval is playing</span>
<a name="l00628"></a>00628                                                 {
<a name="l00629"></a>00629                                                         <span class="keywordflow">if</span> (m_restart-&gt;m_value-&gt;m_value == RESTART_ALWAYS)
<a name="l00630"></a>00630                                                         {
<a name="l00631"></a>00631                                                                 TimeInstance* pInstanceTime = GetNextInstanceTime(m_pCurrentInterval-&gt;m_begin + m_tau);
<a name="l00632"></a>00632 
<a name="l00633"></a>00633                                                                 <span class="keywordflow">if</span> (pInstanceTime &amp;&amp;
<a name="l00634"></a>00634                                                                         (*pInstanceTime &lt; m_pCurrentInterval-&gt;m_end))
<a name="l00635"></a>00635                                                                 {
<a name="l00636"></a>00636                                                                         EndCurrentIntervalAt(*pInstanceTime);
<a name="l00637"></a>00637                                                                 }
<a name="l00638"></a>00638                                                         }
<a name="l00639"></a>00639                                                 }
<a name="l00640"></a>00640                                         }
<a name="l00641"></a>00641                                         <span class="keywordflow">else</span>
<a name="l00642"></a>00642                                         {
<a name="l00643"></a>00643                                                 <span class="comment">// ??</span>
<a name="l00644"></a>00644                                                 m_pCurrentInterval = GetFirstInterval();
<a name="l00645"></a>00645 
<a name="l00646"></a>00646                                                 <span class="keywordflow">if</span> (m_pCurrentInterval)
<a name="l00647"></a>00647                                                 {
<a name="l00648"></a>00648                                                 <span class="comment">// creating (new) interval notify syncbase dependants</span>
<a name="l00649"></a>00649                                                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m_syncDependants.GetSize(); i++)
<a name="l00650"></a>00650                                                         {
<a name="l00651"></a>00651                                                                 m_syncDependants[i]-&gt;NotifySync(static_cast&lt;T*&gt;(<span class="keyword">this</span>), m_pCurrentInterval<span class="comment">/*, VARIANT_TRUE*/</span><span class="comment">/*begin*/</span>);
<a name="l00652"></a>00652                                                         }
<a name="l00653"></a>00653                                                 }
<a name="l00654"></a>00654                                         }
<a name="l00655"></a>00655                                 }
<a name="l00656"></a>00656                         }
<a name="l00657"></a>00657                 }
<a name="l00658"></a>00658 
<a name="l00659"></a>00659                 m_instanceBeginList.Sort();
<a name="l00660"></a>00660 
<a name="l00661"></a>00661                 <span class="keywordflow">for</span> (i = 0; i &lt; m_end-&gt;m_value-&gt;m_value-&gt;m_items.GetSize(); i++)
<a name="l00662"></a>00662                 {
<a name="l00663"></a>00663                 <span class="comment">// TODO,</span>
<a name="l00664"></a>00664 
<a name="l00665"></a>00665                         <span class="comment">//static_cast&lt;T*&gt;(this)-&gt;m_instanceEndList.m_items.Add(pInstanceTime);</span>
<a name="l00666"></a>00666                 }
<a name="l00667"></a>00667 <span class="preprocessor">#endif</span>
<a name="l00668"></a>00668 <span class="preprocessor"></span>        }
<a name="l00669"></a>00669 
<a name="l00670"></a>00670         <span class="keywordtype">double</span> calcActiveEnd(<span class="keywordtype">double</span> begin, <span class="keywordtype">double</span> end = INDEFINITE <span class="comment">/* no end constraint*/</span>);
<a name="l00671"></a>00671 
<a name="l00672"></a>00672         TimeInterval* GetFirstInterval();
<a name="l00673"></a>00673 
<a name="l00674"></a>00674 <span class="comment">// Calculates the next acceptable interval for an element</span>
<a name="l00675"></a>00675 <span class="comment">// Returns:</span>
<a name="l00676"></a>00676 <span class="comment">//    Interval if there is such an interval</span>
<a name="l00677"></a>00677 <span class="comment">//    FAILURE if there is no such interval</span>
<a name="l00678"></a>00678         TimeInterval* GetNextInterval();
<a name="l00679"></a>00679 
<a name="l00680"></a>00680 <span class="comment">// IElementTime</span>
<a name="l00681"></a>00681         FillType get_fill()
<a name="l00682"></a>00682         {
<a name="l00683"></a>00683                 <span class="keywordflow">return</span> m_fill;
<a name="l00684"></a>00684         }
<a name="l00685"></a>00685 
<a name="l00686"></a>00686         <span class="keywordtype">void</span> set_fill(FillType newVal)
<a name="l00687"></a>00687         {
<a name="l00688"></a>00688                 ASSERT(0);
<a name="l00689"></a>00689         }
<a name="l00690"></a>00690 
<a name="l00691"></a>00691         <span class="keywordtype">double</span> get_repeatCount()
<a name="l00692"></a>00692         {
<a name="l00693"></a>00693                 <span class="keywordflow">return</span> m_repeatCount;
<a name="l00694"></a>00694         }
<a name="l00695"></a>00695 
<a name="l00696"></a>00696         <span class="keywordtype">void</span> set_repeatCount(<span class="keywordtype">double</span> newVal)
<a name="l00697"></a>00697         {
<a name="l00698"></a>00698                 ASSERT(0);
<a name="l00699"></a>00699         }
<a name="l00700"></a>00700 
<a name="l00701"></a>00701         <span class="keywordtype">double</span> get_repeatDur()
<a name="l00702"></a>00702         {
<a name="l00703"></a>00703                 <span class="keywordflow">return</span> m_repeatDur;
<a name="l00704"></a>00704         }
<a name="l00705"></a>00705 
<a name="l00706"></a>00706         <span class="keywordtype">void</span> set_repeatDur(<span class="keywordtype">double</span> newVal)
<a name="l00707"></a>00707         {
<a name="l00708"></a>00708                 ASSERT(0);
<a name="l00709"></a>00709         }
<a name="l00710"></a>00710 
<a name="l00711"></a>00711         <span class="keywordtype">double</span> get_dur()
<a name="l00712"></a>00712         {
<a name="l00713"></a>00713                 <span class="keywordflow">return</span> m_dur;
<a name="l00714"></a>00714         }
<a name="l00715"></a>00715 
<a name="l00716"></a>00716         <span class="keywordtype">void</span> set_dur(<span class="keywordtype">double</span> newVal)
<a name="l00717"></a>00717         {
<a name="l00718"></a>00718                 ASSERT(0);
<a name="l00719"></a>00719                 <span class="comment">//m_dur = newVal;</span>
<a name="l00720"></a>00720         }
<a name="l00721"></a>00721 
<a name="l00722"></a>00722         RestartType get_restart()
<a name="l00723"></a>00723         {
<a name="l00724"></a>00724                 <span class="keywordflow">return</span> m_restart;
<a name="l00725"></a>00725         }
<a name="l00726"></a>00726 
<a name="l00727"></a>00727         <span class="keywordtype">void</span> set_restart(RestartType newVal)
<a name="l00728"></a>00728         {
<a name="l00729"></a>00729                 ASSERT(0);
<a name="l00730"></a>00730         }
<a name="l00731"></a>00731 
<a name="l00732"></a>00732         SMILTimeList* get_begin()
<a name="l00733"></a>00733         {
<a name="l00734"></a>00734                 <span class="keywordflow">return</span> m_begin;
<a name="l00735"></a>00735         }
<a name="l00736"></a>00736 
<a name="l00737"></a>00737         SMILTimeList* get_end()
<a name="l00738"></a>00738         {
<a name="l00739"></a>00739                 <span class="keywordflow">return</span> m_end;
<a name="l00740"></a>00740         }
<a name="l00741"></a>00741 
<a name="l00742"></a>00742         <span class="keywordtype">void</span> seekElement( <span class="keywordtype">double</span> seekTo)
<a name="l00743"></a>00743         {
<a name="l00744"></a>00744                 <span class="comment">// TODO</span>
<a name="l00745"></a>00745                 m_tau = seekTo;
<a name="l00746"></a>00746         }
<a name="l00747"></a>00747 
<a name="l00748"></a>00748 <span class="comment">// Time manipulation</span>
<a name="l00749"></a>00749         <span class="keywordtype">double</span> get_speed()
<a name="l00750"></a>00750         {
<a name="l00751"></a>00751                 <span class="comment">//Web::SVGNumberValue* v = m_speed-&gt;m_value-&gt;m_object-&gt;m_value;</span>
<a name="l00752"></a>00752         
<a name="l00753"></a>00753         <span class="comment">//      CValueTypeWrapper&lt;CreateInstance&lt;EnumerationAnimFillType&gt; &gt; &gt;&amp; v = m_speed-&gt;m_value;</span>
<a name="l00754"></a>00754 
<a name="l00755"></a>00755                 <span class="keywordflow">return</span> m_speed;
<a name="l00756"></a>00756         <span class="comment">//      return m_speed-&gt;m_value-&gt;m_object-&gt;m_value;</span>
<a name="l00757"></a>00757                 <span class="comment">//*pVal = m_speed-&gt;m_value-&gt;m_value-&gt;m_value;</span>
<a name="l00758"></a>00758         }
<a name="l00759"></a>00759         <span class="keywordtype">void</span> set_speed(<span class="keywordtype">double</span> newVal)
<a name="l00760"></a>00760         {
<a name="l00761"></a>00761                 ASSERT(0);
<a name="l00762"></a>00762         }
<a name="l00763"></a>00763         <span class="keywordtype">double</span> get_accelerate()
<a name="l00764"></a>00764         {
<a name="l00765"></a>00765                 <span class="keywordflow">return</span> m_accelerate;
<a name="l00766"></a>00766         }
<a name="l00767"></a>00767         <span class="keywordtype">void</span> set_accelerate(<span class="keywordtype">double</span> newVal)
<a name="l00768"></a>00768         {
<a name="l00769"></a>00769                 ASSERT(0);
<a name="l00770"></a>00770         }
<a name="l00771"></a>00771         <span class="keywordtype">double</span> get_decelerate()
<a name="l00772"></a>00772         {
<a name="l00773"></a>00773                 <span class="keywordflow">return</span> m_decelerate;
<a name="l00774"></a>00774         }
<a name="l00775"></a>00775         <span class="keywordtype">void</span> set_decelerate(<span class="keywordtype">double</span> newVal)
<a name="l00776"></a>00776         {
<a name="l00777"></a>00777                 ASSERT(0);
<a name="l00778"></a>00778         }
<a name="l00779"></a>00779         <span class="keywordtype">bool</span> get_autoReverse()
<a name="l00780"></a>00780         {
<a name="l00781"></a>00781                 <span class="keywordflow">return</span> m_autoReverse;
<a name="l00782"></a>00782         }
<a name="l00783"></a>00783         <span class="keywordtype">void</span> set_autoReverse(<span class="keywordtype">bool</span> newVal)
<a name="l00784"></a>00784         {
<a name="l00785"></a>00785                 ASSERT(0);
<a name="l00786"></a>00786         }
<a name="l00787"></a>00787 
<a name="l00788"></a>00788         <span class="keyword">virtual</span> <span class="keywordtype">void</span> Run()
<a name="l00789"></a>00789         {
<a name="l00790"></a>00790         }
<a name="l00791"></a>00791 
<a name="l00792"></a>00792 <span class="preprocessor">#if 0</span>
<a name="l00793"></a>00793 <span class="preprocessor"></span>        <span class="keyword">virtual</span> <span class="keywordtype">void</span> Seek(<span class="comment">/*[in]*/</span> <span class="keywordtype">double</span> tps <span class="comment">/*parent simple time*/</span>)
<a name="l00794"></a>00794         {
<a name="l00795"></a>00795                 <span class="keywordflow">if</span> (m_pCurrentInterval)
<a name="l00796"></a>00796                 {
<a name="l00797"></a>00797                         <span class="keywordflow">if</span> (tps &gt; m_parentSimpleTime)   <span class="comment">// Seeking Forward</span>
<a name="l00798"></a>00798                         {
<a name="l00799"></a>00799                                 <span class="keywordflow">while</span> (1)       <span class="comment">// loop</span>
<a name="l00800"></a>00800                                 {
<a name="l00801"></a>00801                                         <span class="keywordflow">if</span> (m_pCurrentInterval)
<a name="l00802"></a>00802                                         {
<a name="l00803"></a>00803                                                 <span class="comment">// Check if going from inactive to active on the current interval</span>
<a name="l00804"></a>00804                                                 <span class="keywordflow">if</span> (    m_parentSimpleTime &lt;= m_pCurrentInterval-&gt;m_begin &amp;&amp;
<a name="l00805"></a>00805                                                                 !m_pCurrentInterval-&gt;m_bActive &amp;&amp;
<a name="l00806"></a>00806                                                                 tps &gt;= m_pCurrentInterval-&gt;m_begin)     <span class="comment">// From inactive to active</span>
<a name="l00807"></a>00807                                                 {
<a name="l00808"></a>00808                                                         m_pCurrentInterval-&gt;m_bActive = TRUE;
<a name="l00809"></a>00809 
<a name="l00810"></a>00810                                                         InactiveToActive();
<a name="l00811"></a>00811 
<a name="l00812"></a>00812                                                         <span class="comment">//static_cast&lt;CLSMILRegionElement*&gt;(region.p)-&gt;Activate(m_pCurrentInterval-&gt;m_begin, this);</span>
<a name="l00813"></a>00813                                                 }
<a name="l00814"></a>00814 
<a name="l00815"></a>00815                                                 <span class="comment">// Check if ending the current interval</span>
<a name="l00816"></a>00816                                                 <span class="keywordflow">if</span> (m_pCurrentInterval-&gt;m_bActive<span class="comment">//m_parentSimpleTime &lt; m_pCurrentInterval-&gt;m_end)</span>
<a name="l00817"></a>00817                                                         &amp;&amp;      tps &gt;= m_pCurrentInterval-&gt;m_end)       <span class="comment">// From active to stopped</span>
<a name="l00818"></a>00818                                                 {
<a name="l00819"></a>00819                                                         ActiveToInactive();
<a name="l00820"></a>00820                                                 <span class="comment">//</span>
<a name="l00821"></a>00821                                                         m_parentSimpleTime = m_pCurrentInterval-&gt;m_end;
<a name="l00822"></a>00822                                                         EndCurrentIntervalAt(m_pCurrentInterval-&gt;m_end);
<a name="l00823"></a>00823 
<a name="l00824"></a>00824                                                         <span class="keywordflow">continue</span>;
<a name="l00825"></a>00825                                                 }
<a name="l00826"></a>00826                                                 <span class="keywordflow">else</span>
<a name="l00827"></a>00827                                                 {
<a name="l00828"></a>00828                                                         <span class="keywordflow">if</span> (m_restart-&gt;m_value-&gt;m_value == RESTART_ALWAYS)
<a name="l00829"></a>00829                                                         {
<a name="l00830"></a>00830                                                                 TimeInstance* pInstanceTime = GetNextInstanceTime(m_pCurrentInterval-&gt;m_begin);
<a name="l00831"></a>00831 
<a name="l00832"></a>00832                                                                 <span class="keywordflow">if</span> (pInstanceTime &amp;&amp;
<a name="l00833"></a>00833                                                                         (tps &gt;= *pInstanceTime &amp;&amp; *pInstanceTime &lt; m_pCurrentInterval-&gt;m_end))
<a name="l00834"></a>00834                                                                 {
<a name="l00835"></a>00835                                                                         ActiveToInactive();
<a name="l00836"></a>00836 
<a name="l00837"></a>00837                                                                         m_parentSimpleTime = *pInstanceTime;
<a name="l00838"></a>00838                                                                         EndCurrentIntervalAt(*pInstanceTime);
<a name="l00839"></a>00839 
<a name="l00840"></a>00840                                                                         <span class="keywordflow">continue</span>;
<a name="l00841"></a>00841                                                                 }
<a name="l00842"></a>00842                                                         }
<a name="l00843"></a>00843                                                 }
<a name="l00844"></a>00844                                         }
<a name="l00845"></a>00845 
<a name="l00846"></a>00846                                         m_parentSimpleTime = tps;
<a name="l00847"></a>00847                                         <span class="keywordflow">break</span>;
<a name="l00848"></a>00848                                 }
<a name="l00849"></a>00849                         }
<a name="l00850"></a>00850                         <span class="keywordflow">else</span>    <span class="comment">// Seeking backwards</span>
<a name="l00851"></a>00851                         {
<a name="l00852"></a>00852                                 {
<a name="l00853"></a>00853                                         <span class="keywordflow">if</span> (m_pCurrentInterval)
<a name="l00854"></a>00854                                         {
<a name="l00855"></a>00855                                                 <span class="comment">// Check if active interval goes back to being inactive</span>
<a name="l00856"></a>00856                                                 <span class="keywordflow">if</span> (    m_pCurrentInterval-&gt;m_bActive &amp;&amp;
<a name="l00857"></a>00857 
<a name="l00858"></a>00858                                                                 m_parentSimpleTime &gt; m_pCurrentInterval-&gt;m_begin &amp;&amp;
<a name="l00859"></a>00859                                                                 tps &lt; m_pCurrentInterval-&gt;m_begin)      <span class="comment">// From inactive to active</span>
<a name="l00860"></a>00860                                                 {
<a name="l00861"></a>00861                                                         m_pCurrentInterval-&gt;m_bActive = FALSE;
<a name="l00862"></a>00862 
<a name="l00863"></a>00863                                                         ActiveToInactive();
<a name="l00864"></a>00864                                                         <span class="comment">/*</span>
<a name="l00865"></a>00865 <span class="comment">                                                // Remove from sandwich model</span>
<a name="l00866"></a>00866 <span class="comment">                                                        UPOSITION pos = pAnimationTarget-&gt;m_animationList.Find(static_cast&lt;CLAnimationElement*&gt;(this));</span>
<a name="l00867"></a>00867 <span class="comment">                                                        ASSERT(pos);</span>
<a name="l00868"></a>00868 <span class="comment">                                                        pAnimationTarget-&gt;m_animationList.RemoveAt(pos);</span>
<a name="l00869"></a>00869 <span class="comment">                                                        */</span>
<a name="l00870"></a>00870 
<a name="l00871"></a>00871                                                         <span class="comment">//pThis-&gt;m_parentSimpleTime = pThis-&gt;m_pCurrentInterval-&gt;m_end;</span>
<a name="l00872"></a>00872                                                         <span class="comment">//pThis-&gt;EndCurrentIntervalAt(pThis-&gt;m_pCurrentInterval-&gt;m_end);</span>
<a name="l00873"></a>00873                                                 }
<a name="l00874"></a>00874                                         }
<a name="l00875"></a>00875 
<a name="l00876"></a>00876                                         m_parentSimpleTime = tps;
<a name="l00877"></a>00877                                 }
<a name="l00878"></a>00878                         }
<a name="l00879"></a>00879 
<a name="l00880"></a>00880                         <span class="keywordtype">double</span> parent_speed = 1;
<a name="l00881"></a>00881                         <span class="keywordtype">double</span> AD = m_AD;<span class="comment">//m_dur;// ? AD=Active Duration?</span>
<a name="l00882"></a>00882                         <span class="keywordtype">double</span> speed = m_speed-&gt;m_value-&gt;m_value;
<a name="l00883"></a>00883                         <span class="keywordtype">double</span> acc = m_accelerate-&gt;m_value-&gt;m_value;
<a name="l00884"></a>00884                         <span class="keywordtype">double</span> dec = m_decelerate-&gt;m_value-&gt;m_value;
<a name="l00885"></a>00885 
<a name="l00886"></a>00886                         <span class="keywordflow">if</span> (acc+dec &gt; 1)        <span class="comment">// Ignore both attributes</span>
<a name="l00887"></a>00887                         {
<a name="l00888"></a>00888                                 acc = 0;
<a name="l00889"></a>00889                                 dec = 0;
<a name="l00890"></a>00890                         }
<a name="l00891"></a>00891                         <span class="comment">//if (speed == 0) speed = 0 ??</span>
<a name="l00892"></a>00892 
<a name="l00893"></a>00893                         m_tau = tps - m_pCurrentInterval-&gt;m_begin;
<a name="l00894"></a>00894 
<a name="l00895"></a>00895                         <span class="keywordtype">double</span> taf;
<a name="l00896"></a>00896 
<a name="l00897"></a>00897                         <span class="keywordflow">if</span> (speed &gt; 0) <span class="comment">// i.e. if the local speed is forwards </span>
<a name="l00898"></a>00898                                 taf = m_tau * speed;
<a name="l00899"></a>00899                         <span class="keywordflow">else</span> <span class="comment">//  i.e. if the local speed is backwards </span>
<a name="l00900"></a>00900                                 taf = AD - m_tau * fabs(speed);
<a name="l00901"></a>00901 
<a name="l00902"></a>00902                         <span class="comment">//Let dur be the value of the simple duration as defined by the Timing and Synchronization model.</span>
<a name="l00903"></a>00903                         <span class="comment">// This is the actual simple duration, and not simply the dur attribute.</span>
<a name="l00904"></a>00904                         <span class="comment">//This value does not account for the effect of any time manipulations.</span>
<a name="l00905"></a>00905                         <span class="keywordtype">double</span> dur = m_dur;
<a name="l00906"></a>00906                         <span class="keywordflow">if</span> (dur &lt; 0) dur = INDEFINITE;  <span class="comment">// indefinite (Is this correct?)</span>
<a name="l00907"></a>00907 
<a name="l00908"></a>00908                         <span class="comment">// pThis-&gt;m_simpleDur has accounted for autoReverse</span>
<a name="l00909"></a>00909                         <span class="keywordtype">double</span> dur_ = m_simpleDur;
<a name="l00910"></a>00910 
<a name="l00911"></a>00911                         <span class="keywordtype">double</span> tsu = REMAINDER(taf, dur_);
<a name="l00912"></a>00912 
<a name="l00913"></a>00913                         {       <span class="comment">// ??</span>
<a name="l00914"></a>00914                                 m_iteration = (int)(taf/dur_);
<a name="l00915"></a>00915                         }
<a name="l00916"></a>00916 
<a name="l00917"></a>00917                 <span class="comment">// Account for autoReverse behavior.</span>
<a name="l00918"></a>00918                         <span class="keywordtype">double</span> tsu_;
<a name="l00919"></a>00919 
<a name="l00920"></a>00920                         <span class="keywordflow">if</span> (m_autoReverse-&gt;m_value-&gt;m_value != VARIANT_TRUE)
<a name="l00921"></a>00921                         {
<a name="l00922"></a>00922                                 tsu_ = tsu;
<a name="l00923"></a>00923                         }
<a name="l00924"></a>00924                         <span class="keywordflow">else</span>
<a name="l00925"></a>00925                         {
<a name="l00926"></a>00926                                 <span class="keywordflow">if</span> (tsu &lt; dur)
<a name="l00927"></a>00927                                         tsu_ = tsu;
<a name="l00928"></a>00928                                 <span class="keywordflow">else</span>
<a name="l00929"></a>00929                                         <span class="comment">//tsu_ = /*dur - (tsu - dur) =*/ 2*dur - tsu;</span>
<a name="l00930"></a>00930                                         tsu_ = 2*dur - tsu;
<a name="l00931"></a>00931                         }
<a name="l00932"></a>00932 
<a name="l00933"></a>00933                 <span class="comment">// Calculate filtered time (tsf)</span>
<a name="l00934"></a>00934 
<a name="l00935"></a>00935                 <span class="comment">// Account for acceleration/deceleration</span>
<a name="l00936"></a>00936                         <span class="keywordtype">double</span> tsf;
<a name="l00937"></a>00937 
<a name="l00938"></a>00938                         <span class="keywordtype">double</span> dacc = acc*dur;
<a name="l00939"></a>00939                         <span class="keywordtype">double</span> ddec = dec*dur;
<a name="l00940"></a>00940 
<a name="l00941"></a>00941                         <span class="keywordtype">double</span> r = 1 / (1 - acc/2 - dec/2);
<a name="l00942"></a>00942 
<a name="l00943"></a>00943                         <span class="keywordflow">if</span> (tsu_ &lt; dacc)
<a name="l00944"></a>00944                         {
<a name="l00945"></a>00945                                 <span class="keywordtype">double</span> rt = r * (tsu_ / dacc);
<a name="l00946"></a>00946 
<a name="l00947"></a>00947                                 tsf = tsu_ * rt / 2;
<a name="l00948"></a>00948                         }
<a name="l00949"></a>00949                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (tsu_ &gt; (dur - ddec))
<a name="l00950"></a>00950                         {
<a name="l00951"></a>00951                                 <span class="keywordtype">double</span> rt = r * (dur - tsu_) / ddec;
<a name="l00952"></a>00952 
<a name="l00953"></a>00953                                 <span class="keywordtype">double</span> tdec =  tsu_ - (dur - ddec);
<a name="l00954"></a>00954                                 <span class="keywordtype">double</span> pd =  tdec / ddec;
<a name="l00955"></a>00955 
<a name="l00956"></a>00956                                 tsf = r * (dur - dacc / 2 - ddec + tdec * (2 - pd) / 2);
<a name="l00957"></a>00957                         }
<a name="l00958"></a>00958                         <span class="keywordflow">else</span>
<a name="l00959"></a>00959                         {
<a name="l00960"></a>00960                                 tsf = r * (tsu_ - dacc / 2);
<a name="l00961"></a>00961                         }
<a name="l00962"></a>00962 
<a name="l00963"></a>00963                         m_tsf = tsf;
<a name="l00964"></a>00964                 }
<a name="l00965"></a>00965         }
<a name="l00966"></a>00966 <span class="preprocessor">#endif</span>
<a name="l00967"></a>00967 <span class="preprocessor"></span>
<a name="l00968"></a>00968 <span class="preprocessor">#if 0   // Had this</span>
<a name="l00969"></a>00969 <span class="preprocessor"></span>        <span class="keywordtype">void</span> Hyperlink(ILSVGSVGElement* svgsvgElement, <span class="keywordtype">double</span> currentTime)
<a name="l00970"></a>00970         {
<a name="l00971"></a>00971                 <span class="keywordflow">if</span> (m_pCurrentInterval &amp;&amp; m_pCurrentInterval-&gt;m_bActive)
<a name="l00972"></a>00972                 {
<a name="l00973"></a>00973                         ASSERT(0);
<a name="l00974"></a>00974                 }
<a name="l00975"></a>00975                 <span class="keywordflow">else</span>
<a name="l00976"></a>00976                 {
<a name="l00977"></a>00977                         <span class="keywordtype">double</span> tempBegin = INDEFINITE;<span class="comment">//?? 999999999;</span>
<a name="l00978"></a>00978                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m_instanceBeginList.m_items.GetSize(); i++)
<a name="l00979"></a>00979                         {
<a name="l00980"></a>00980                                 <span class="keywordflow">if</span> (*m_instanceBeginList.m_items[i] &lt; tempBegin)
<a name="l00981"></a>00981                                 {
<a name="l00982"></a>00982                                         tempBegin = *m_instanceBeginList.m_items[i];
<a name="l00983"></a>00983                                         <span class="comment">//break;</span>
<a name="l00984"></a>00984                                 }
<a name="l00985"></a>00985                         }
<a name="l00986"></a>00986 
<a name="l00987"></a>00987                         <span class="keywordflow">if</span> (tempBegin &lt; INDEFINITE)
<a name="l00988"></a>00988                         {
<a name="l00989"></a>00989                                 svgsvgElement-&gt;setCurrentTime(tempBegin);
<a name="l00990"></a>00990                         }
<a name="l00991"></a>00991                         <span class="keywordflow">else</span>
<a name="l00992"></a>00992                         {
<a name="l00993"></a>00993                                 TimeInstance* pInstanceTime = <span class="keyword">new</span> TimeInstance;
<a name="l00994"></a>00994 
<a name="l00995"></a>00995                                 pInstanceTime-&gt;m_time = NULL;<span class="comment">//m_begin-&gt;m_items[i];</span>
<a name="l00996"></a>00996                                 pInstanceTime-&gt;m_resolvedTime = currentTime;<span class="comment">//pInstanceTime-&gt;m_time-&gt;m_offset;</span>
<a name="l00997"></a>00997                                 m_instanceBeginList.m_items.Add(pInstanceTime);
<a name="l00998"></a>00998 
<a name="l00999"></a>00999                                 m_pCurrentInterval = GetFirstInterval();        <span class="comment">// ??</span>
<a name="l01000"></a>01000 
<a name="l01001"></a>01001                                 <span class="keywordflow">if</span> (m_pCurrentInterval)
<a name="l01002"></a>01002                                 {
<a name="l01003"></a>01003                                 <span class="comment">// creating (new) interval notify syncbase dependants</span>
<a name="l01004"></a>01004                                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m_syncDependants.GetSize(); i++)
<a name="l01005"></a>01005                                         {
<a name="l01006"></a>01006                                                 m_syncDependants[i]-&gt;NotifySync(static_cast&lt;T*&gt;(<span class="keyword">this</span>), m_pCurrentInterval<span class="comment">/*, VARIANT_TRUE*/</span><span class="comment">/*begin*/</span>);
<a name="l01007"></a>01007                                         }
<a name="l01008"></a>01008                                 }
<a name="l01009"></a>01009                         }
<a name="l01010"></a>01010                 }
<a name="l01011"></a>01011         }
<a name="l01012"></a>01012 <span class="preprocessor">#endif</span>
<a name="l01013"></a>01013 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l01014"></a>01014 <span class="comment">If a DOM method call is made to begin or end the element</span>
<a name="l01015"></a>01015 <span class="comment">(beginElement(), beginElementAt(), endElement() or endElementAt()), each method</span>
<a name="l01016"></a>01016 <span class="comment">call creates a single instance time (in the appropriate instance times list).</span>
<a name="l01017"></a>01017 <span class="comment">These time instances are cleared upon reset just as for event times</span>
<a name="l01018"></a>01018 <span class="comment">*/</span>
<a name="l01019"></a>01019 
<a name="l01020"></a>01020 <span class="comment">/*</span>
<a name="l01021"></a>01021 <span class="comment">        Causes this element to begin the local timeline (subject to sync constraints). </span>
<a name="l01022"></a>01022 <span class="comment">*/</span>
<a name="l01023"></a>01023         <span class="keywordtype">bool</span> beginElement();
<a name="l01024"></a>01024 
<a name="l01025"></a>01025 <span class="comment">/*</span>
<a name="l01026"></a>01026 <span class="comment">        Causes this element to begin the local timeline (subject to sync constraints),</span>
<a name="l01027"></a>01027 <span class="comment">        at the passed offset from the current time when the method is called. If the</span>
<a name="l01028"></a>01028 <span class="comment">        offset is &gt;= 0, the semantics are equivalent to an event-base begin with the</span>
<a name="l01029"></a>01029 <span class="comment">        specified offset. If the offset is &lt; 0, the semantics are equivalent to</span>
<a name="l01030"></a>01030 <span class="comment">        beginElement(), but the element active duration is evaluated as though the element</span>
<a name="l01031"></a>01031 <span class="comment">        had begun at the passed (negative) offset from the current time when the method is</span>
<a name="l01032"></a>01032 <span class="comment">        called. </span>
<a name="l01033"></a>01033 <span class="comment">*/</span>
<a name="l01034"></a>01034         <span class="keywordtype">bool</span> beginElementAt(<span class="comment">/*[in]*/</span> <span class="keywordtype">double</span> offset);
<a name="l01035"></a>01035 
<a name="l01036"></a>01036         <span class="keywordtype">bool</span> endElement();
<a name="l01037"></a>01037 
<a name="l01038"></a>01038         <span class="keywordtype">bool</span> endElementAt(<span class="comment">/*[in]*/</span> <span class="keywordtype">double</span> offset);
<a name="l01039"></a>01039 
<a name="l01040"></a>01040 <span class="comment">// Extensions</span>
<a name="l01041"></a>01041         <span class="keywordtype">double</span> get_simpleTime()
<a name="l01042"></a>01042         {
<a name="l01043"></a>01043                 <span class="keywordflow">return</span> m_tsf;
<a name="l01044"></a>01044         }
<a name="l01045"></a>01045 
<a name="l01046"></a>01046         <span class="keywordtype">double</span> get_activeTime()
<a name="l01047"></a>01047         {
<a name="l01048"></a>01048                 <span class="keywordflow">return</span> m_tau;
<a name="l01049"></a>01049         }
<a name="l01050"></a>01050 
<a name="l01051"></a>01051         <span class="keywordtype">double</span> getSimpleDuration()
<a name="l01052"></a>01052         {
<a name="l01053"></a>01053                 <span class="keywordflow">return</span> m_simpleDur;
<a name="l01054"></a>01054         }
<a name="l01055"></a>01055 
<a name="l01056"></a>01056         <span class="keywordtype">double</span> getActiveDuration()
<a name="l01057"></a>01057         {
<a name="l01058"></a>01058                 <span class="keywordflow">return</span> m_AD;
<a name="l01059"></a>01059         }
<a name="l01060"></a>01060 
<a name="l01061"></a>01061         TimeInterval* get_currentInterval()
<a name="l01062"></a>01062         {
<a name="l01063"></a>01063                 <span class="keywordflow">return</span> m_pCurrentInterval;
<a name="l01064"></a>01064         }
<a name="l01065"></a>01065 
<a name="l01066"></a>01066         <span class="comment">/*</span>
<a name="l01067"></a>01067 <span class="comment">        double ActiveTimeToSimpleTime(double tau)</span>
<a name="l01068"></a>01068 <span class="comment">        {</span>
<a name="l01069"></a>01069 <span class="comment">                return ElementTimeImpl::ActiveTimeToSimpleTime(tau);</span>
<a name="l01070"></a>01070 <span class="comment">        }</span>
<a name="l01071"></a>01071 <span class="comment">        */</span>
<a name="l01072"></a>01072 
<a name="l01073"></a>01073 <span class="preprocessor">#if 0</span>
<a name="l01074"></a>01074 <span class="preprocessor"></span>        STDMETHODIMP SimpleTimeToActiveTime(<span class="keywordtype">double</span> tsf, <span class="keywordtype">double</span>* pVal)
<a name="l01075"></a>01075         {
<a name="l01076"></a>01076                 <span class="keywordflow">if</span> (pVal == NULL) <span class="keywordflow">return</span> E_POINTER;
<a name="l01077"></a>01077                 *pVal = ElementTimeImpl::SimpleTimeToActiveTime(tsf);
<a name="l01078"></a>01078                 <span class="keywordflow">return</span> S_OK;
<a name="l01079"></a>01079         }
<a name="l01080"></a>01080 <span class="preprocessor">#endif</span>
<a name="l01081"></a>01081 <span class="preprocessor"></span>
<a name="l01082"></a>01082         <span class="keyword">virtual</span> <span class="keywordtype">void</span> Seek(<span class="keywordtype">double</span> tps);
<a name="l01083"></a>01083 
<a name="l01084"></a>01084         <span class="keywordtype">double</span> ActiveTimeToSimpleTime(<span class="keywordtype">double</span> tau);
<a name="l01085"></a>01085         <span class="keywordtype">double</span> SimpleTimeToActiveTime(<span class="keywordtype">double</span> tsf);
<a name="l01086"></a>01086 
<a name="l01087"></a>01087 <span class="comment">// Seek is only implemented here and calls Activate/Deactivate handled by</span>
<a name="l01088"></a>01088 <span class="comment">// the classes derived from IElementTime</span>
<a name="l01089"></a>01089 
<a name="l01090"></a>01090         <span class="keyword">virtual</span> <span class="keywordtype">void</span> ActiveToInactive()
<a name="l01091"></a>01091         {
<a name="l01092"></a>01092         }
<a name="l01093"></a>01093 
<a name="l01094"></a>01094         <span class="keyword">virtual</span> <span class="keywordtype">void</span> InactiveToActive()
<a name="l01095"></a>01095         {
<a name="l01096"></a>01096         }
<a name="l01097"></a>01097 
<a name="l01098"></a>01098         TimeInstance* GetNextInstanceTime(<span class="keywordtype">double</span> beginAfter)
<a name="l01099"></a>01099         {
<a name="l01100"></a>01100                 <span class="comment">//double beginAfter = m_pCurrentInterval-&gt;m_begin;</span>
<a name="l01101"></a>01101 
<a name="l01102"></a>01102                 <span class="comment">//double tempBegin;</span>
<a name="l01103"></a>01103 
<a name="l01104"></a>01104                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
<a name="l01105"></a>01105                 <span class="keywordflow">for</span> (i = 0; i &lt; m_instanceBeginList.m_items.size(); i++)
<a name="l01106"></a>01106                 {
<a name="l01107"></a>01107                         <span class="keywordflow">if</span> (*m_instanceBeginList.m_items[i] &gt; beginAfter)
<a name="l01108"></a>01108                         {
<a name="l01109"></a>01109                         <span class="comment">//      tempBegin = *m_instanceBeginList.m_items[i];</span>
<a name="l01110"></a>01110                                 <span class="keywordflow">break</span>;
<a name="l01111"></a>01111                         }
<a name="l01112"></a>01112                 }
<a name="l01113"></a>01113 
<a name="l01114"></a>01114                 <span class="keywordflow">if</span> (i &lt; m_instanceBeginList.m_items.size())
<a name="l01115"></a>01115                 {
<a name="l01116"></a>01116 <span class="comment">//                      if (*m_instanceBeginList.m_items[i] &lt; m_pCurrentInterval-&gt;m_end)</span>
<a name="l01117"></a>01117                         {
<a name="l01118"></a>01118                                 <span class="keywordflow">return</span> m_instanceBeginList.m_items[i];
<a name="l01119"></a>01119                         }
<a name="l01120"></a>01120                 }
<a name="l01121"></a>01121 
<a name="l01122"></a>01122                 <span class="keywordflow">return</span> NULL;
<a name="l01123"></a>01123         }
<a name="l01124"></a>01124 
<a name="l01125"></a>01125 <span class="keyword">public</span>:
<a name="l01126"></a>01126 
<a name="l01127"></a>01127         <span class="keywordtype">double</span> m_parentSimpleTime;
<a name="l01128"></a>01128 
<a name="l01129"></a>01129         Element* m_ownerElement;
<a name="l01130"></a>01130 
<a name="l01131"></a>01131         <span class="keywordtype">int</span> m_iteration;
<a name="l01132"></a>01132 
<a name="l01133"></a>01133         <span class="keywordtype">double</span> m_tau;   <span class="comment">// Unfiltered active time</span>
<a name="l01134"></a>01134         <span class="keywordtype">double</span> m_tsf;   <span class="comment">// Filtered simple time</span>
<a name="l01135"></a>01135 
<a name="l01136"></a>01136         <span class="keywordtype">double</span> m_dur;                   <span class="comment">// &#39;dur&#39; attribute, desired simple time (&lt;0 means indefinite)</span>
<a name="l01137"></a>01137         <span class="keywordtype">double</span> m_simpleDur;     <span class="comment">// Simple duration (autoReverse Accounted for)</span>
<a name="l01138"></a>01138         <span class="keywordtype">double</span> m_AD;    <span class="comment">// Active Duration</span>
<a name="l01139"></a>01139 
<a name="l01140"></a>01140         <span class="keywordtype">double</span> m_clipBegin;     <span class="comment">// TODO, improve</span>
<a name="l01141"></a>01141 
<a name="l01142"></a>01142 <span class="comment">//      CComObject&lt;CXMLAttr2T&lt;CComObjectCreateInstance&lt;CValueTypeWrapper&lt;CLClockValue&gt; &gt; &gt; &gt;* m_dur;</span>
<a name="l01143"></a>01143 
<a name="l01144"></a>01144         InstanceTimeList m_instanceBeginList;
<a name="l01145"></a>01145         InstanceTimeList m_instanceEndList;
<a name="l01146"></a>01146         vector&lt;TimeInterval*&gt; m_intervals;
<a name="l01147"></a>01147         TimeInterval* m_pCurrentInterval;
<a name="l01148"></a>01148 
<a name="l01149"></a>01149         vector&lt;ElementTime*&gt; m_syncDependants;
<a name="l01150"></a>01150 
<a name="l01151"></a>01151 <span class="comment">//      CComObject&lt;CXMLAttr2T&lt;CComObjectCreateInstance&lt;CValueTypeWrapper&lt;CDurationValue&gt; &gt; &gt; &gt;* m_dur;</span>
<a name="l01152"></a>01152 
<a name="l01153"></a>01153         SMILTimeList* m_begin;
<a name="l01154"></a>01154         SMILTimeList* m_end;
<a name="l01155"></a>01155         <span class="keywordtype">double</span> m_repeatDur;
<a name="l01156"></a>01156         <span class="keywordtype">double</span> m_repeatCount;
<a name="l01157"></a>01157         <span class="keywordtype">double</span> m_accelerate;
<a name="l01158"></a>01158         <span class="keywordtype">double</span> m_decelerate;
<a name="l01159"></a>01159         <span class="keywordtype">double</span> m_speed;
<a name="l01160"></a>01160         RestartType m_restart;
<a name="l01161"></a>01161         FillType m_fill;
<a name="l01162"></a>01162         <span class="keywordtype">bool</span> m_autoReverse;
<a name="l01163"></a>01163 
<a name="l01164"></a>01164         Attr* m_durAttr;
<a name="l01165"></a>01165         Attr* m_beginAttr;
<a name="l01166"></a>01166         Attr* m_endAttr;
<a name="l01167"></a>01167         Attr* m_repeatDurAttr;
<a name="l01168"></a>01168         Attr* m_repeatCountAttr;
<a name="l01169"></a>01169         Attr* m_restartAttr;
<a name="l01170"></a>01170         Attr* m_fillAttr;
<a name="l01171"></a>01171         Attr* m_accelerateAttr;
<a name="l01172"></a>01172         Attr* m_decelerateAttr;
<a name="l01173"></a>01173         Attr* m_speedAttr;
<a name="l01174"></a>01174         Attr* m_autoReverseAttr;
<a name="l01175"></a>01175 };
<a name="l01176"></a>01176 
<a name="l01177"></a>01177 }       <span class="comment">// w3c</span>
<a name="l01178"></a>01178 }
<a name="l01179"></a>01179 
<a name="l01180"></a>01180 <span class="preprocessor">#endif  // w3c_ElementTime_h</span>
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerator</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Sat Dec 17 2011 00:57:16 for FirstProject2 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
